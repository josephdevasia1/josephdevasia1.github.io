// This file was generated by Slater.app - index.js 


gsap.registerPlugin(ScrollTrigger, SplitText, CustomEase);

let staggerDefault = 0.07;
let durationDefault = 1.47;
let durationDefaultFast = 0.35;
let durationPageTransition = 0.735;

let scroll;
let transitionOffset = 400;
let splineRemoved = false;

let mainNavBarHeight = $('.main-nav-bar').innerHeight();
$(window).resize(function () { mainNavBarHeight = $('.main-nav-bar').innerHeight(); });

CustomEase.create("primary-ease", "0.62, 0.05, 0.01, 0.99");

initPageTransitions();

// Animation - Page Loader
function initLoader() {

  var tl = gsap.timeline();

  tl.set(".transition-screen", {
    autoAlpha: 0
  }, 0);

  tl.to(".loading-screen .loading-screen__icon-dark", {
    // transformOrigin: 'right',
    scaleX: 0,
    ease: "Power4.easeInOut",
    duration: 0.7,
  }, 0);

  tl.to(".loading-screen", {
    autoAlpha: 0,
    ease: "Power2.easeOut",
    duration: durationPageTransition,
  }, 1.1);

  tl.to(".loading-screen .loading-screen__icon", {
    scale: 0.8,
    ease: "Power4.ease",
    duration: durationPageTransition,
  }, 0.9);

  tl.call(function () {
    scroll.stop();
    pageTransitionOut();
  }, null, 1.1);

  tl.call(function () {
    checkSlowDevice();
  }, null, 4);

}

// Animation - Page Leave
function pageTransitionIn() {
  var tl = gsap.timeline();

  if (document.querySelector('.lorem-ipsum')) {}

  tl.set(".transition-screen", {
    autoAlpha: 0,
  }, 0);

  tl.to(".transition-screen", {
    autoAlpha: 1,
    ease: "primary-ease",
    duration: 0.35,
  }, 0);

  tl.to(".transition-screen", {
    autoAlpha: 0,
    ease: "Power2.easeOut",
    duration: durationPageTransition,
  }, 0.65);

}

// Animation - Page Enter
function pageTransitionOut() {
  var tl = gsap.timeline();

  tl.fromTo("[data-split-words][data-animation-transition] .single-word-inner", {
    yPercent: 120,
    rotate: 0.001
  }, {
    yPercent: 0,
    rotate: 0.001,
    ease: "primary-ease",
    duration: durationDefault,
    stagger: staggerDefault,
    clearProps: "all"
  }, 0.2);

  if (document.querySelector('[data-animation-transition="fade"]')) {
    tl.fromTo('[data-animation-transition="fade"]', {
      y: "2em",
      rotate: 0.001,
      autoAlpha: 0
    }, {
      y: 0,
      rotate: 0.001,
      autoAlpha: 1,
      ease: "Expo.easeOut",
      duration: durationDefault,
      stagger: staggerDefault
    }, 0.5);
  }

  tl.call(function () {
    scroll.start();
  }, null, 0.2);

}

function initPageTransitions() {

  // Common Leave (Before Offset)
  async function commonLeaveBeforeOffset(data) {
    pageTransitionIn(data.current);
    initNavigationFunctions();

    // Reset attributes
    $('[data-navigation-status]').attr('data-navigation-status', 'not-active');

    // Namespace read and apply
    const [themeNameSpace, bgNameSpace] = data.next.namespace.split('-');
    $('[data-theme-transition]').attr('data-theme-transition', themeNameSpace);
    $('[data-bg-transition]').attr('data-bg-transition', bgNameSpace);
    $('[data-theme-nav]').attr('data-theme-nav', themeNameSpace);
    $('[data-bg-nav]').attr('data-bg-nav', bgNameSpace);

  }

  // Common Leave (After Offset)
  async function commonLeaveAfterOffset(data) {
    initBarbaNavUpdate(data);
    scroll.destroy();
    killAllScrollTriggers();
    data.current.container.remove();

    // Reset attributes
    $('[data-navigation-status]').attr('data-navigation-status', 'not-active');
    $('[data-scrolling-direction]').attr('data-scrolling-direction', 'down');
    $('[data-scrolling-started]').attr('data-scrolling-started', 'false');

    // Namespace read and apply
    const [themeNameSpace, bgNameSpace] = data.next.namespace.split('-');
    $('[data-theme-page]').attr('data-theme-page', themeNameSpace);
    $('[data-bg-page]').attr('data-bg-page', bgNameSpace);

  }

  // Common enter
  async function commonEnter(data) {
    pageTransitionOut(data.next);
  }

  // Common beforeEnter
  async function commonBeforeEnter(data) {
    ScrollTrigger.getAll().forEach(t => t.kill());
    initResetWebflow(data);
    initSmoothScroll(data.next.container);
    initScript();
  }

  // Common afterEnter
  async function commonAfterEnter(data) {
    window.scrollTo(0, 0);
    ScrollTrigger.refresh();
  }

  barba.init({
    sync: true,
    debug: true,
    timeout: 7000,
    transitions: [{
      name: 'to-light-blue',
      from: {},
      to: {
        namespace: ['light-blue']
      },
      async leave(data) {
        await commonLeaveBeforeOffset(data);
        await delay(transitionOffset);
        await commonLeaveAfterOffset(data);
      },
      async enter(data) {
        await commonEnter(data);
      },
      async beforeEnter(data) {
        await commonBeforeEnter(data);
      },
      async afterEnter(data) {
        await commonAfterEnter(data);
      }
    }, {
      name: 'to-lightsecondary-blue',
      from: {},
      to: {
        namespace: ['lightsecondary-blue']
      },
      async leave(data) {
        await commonLeaveBeforeOffset(data);
        await delay(transitionOffset);
        await commonLeaveAfterOffset(data);
      },
      async enter(data) {
        await commonEnter(data);
      },
      async beforeEnter(data) {
        await commonBeforeEnter(data);
      },
      async afterEnter(data) {
        await commonAfterEnter(data);
      }
    }, {
      name: 'to-dark-yellow',
      from: {},
      to: {
        namespace: ['dark-yellow']
      },
      async leave(data) {
        await commonLeaveBeforeOffset(data);
        await delay(transitionOffset);
        await commonLeaveAfterOffset(data);
      },
      async enter(data) {
        await commonEnter(data);
      },
      async beforeEnter(data) {
        await commonBeforeEnter(data);
      },
      async afterEnter(data) {
        await commonAfterEnter(data);
      }
    }, {
      name: 'self',
      async leave(data) {
        await commonLeaveBeforeOffset(data);
        await delay(transitionOffset);
        await commonLeaveAfterOffset(data);
      },
      async enter(data) {
        await commonEnter(data);
      },
      async beforeEnter(data) {
        await commonBeforeEnter(data);
      },
      async afterEnter(data) {
        await commonAfterEnter(data);
      }
    }, {
      name: 'default',
      once(data) {
        checkSlowDevice();
        initSmoothScroll(data.next.container);
        checkDevice();
        initScript();
      },
      async leave(data) {
        await commonLeaveBeforeOffset(data);
        await delay(transitionOffset);
        await commonLeaveAfterOffset(data);
      },
      async enter(data) {
        await commonEnter(data);
      },
      async beforeEnter(data) {
        await commonBeforeEnter(data);
      },
      async afterEnter(data) {
        await commonAfterEnter(data);
      }
    }]
  });

  function initSmoothScroll(container) {
    initLenis();
    ScrollTrigger.refresh();
  }

  // Function to kill all ScrollTrigger data
  function killAllScrollTriggers() {
    if (typeof ScrollTrigger !== 'undefined') {
      // Kill all ScrollTrigger instances
      ScrollTrigger.killAll();
    }
  }

  // Reset scroll on page next
  history.scrollRestoration = "manual";
}

function initLenis() {

  // Lenis: https://github.com/studio-freight/lenis
  scroll = new Lenis({
    lerp: 0.165,
    wheelMultiplier: 1.25,
  });

  scroll.on('scroll', ScrollTrigger.update);

  gsap.ticker.add((time) => {
    scroll.raf(time * 1000);
  });

  gsap.ticker.lagSmoothing(0);
}

// Function to remove Spline

function removeSplineDirect() {
  if (splineRemoved == false) {
    splineRemoved = true;
    $('.spline-bg__spline').remove();
  }
}

function removeSpline() {
  if (splineRemoved == false) {
    splineRemoved = true;
    gsap.to(".spline-bg__spline", {
      opacity: 0,
      ease: "Power1.easeInOut",
      duration: 0.3,
      onComplete: () => {
        $('.spline-bg__spline').remove();
      }
    });

    gsap.fromTo("[data-notification-3D]", {
      autoAlpha: 0,
      yPercent: 100
    }, {
      autoAlpha: 1,
      ease: "primary-ease",
      duration: durationDefault,
      yPercent: 0,
      delay: 1
    });

    gsap.to("[data-notification-3D]", {
      autoAlpha: 0,
      yPercent: 100,
      ease: "primary-ease",
      duration: durationDefault,
      delay: 4
    });
  }
}
// Function to check if device is mobile or desktop
function checkDevice() {
  // Define a breakpoint width for mobile and tablet devices
  const mobileTabletBreakpoint = 911; // Adjust this value as needed

  // Check if the screen width is less than or equal to the breakpoint
  if (window.innerWidth <= mobileTabletBreakpoint) {
    removeSplineDirect();
    initLoader();
  } else {
    if (splineRemoved == false) {
      splineLoaded(false, initLoader);
    } else {
      initLoader();
    }
  }
}

// Function to test if the device is slow
function checkSlowDevice() {

  if (splineRemoved == true) {
    return;
  }

  let frameTimes = [];
  let lowFpsDuration = 0;
  const thresholdFps = 15;
  const thresholdDuration = 1000; //in milliseconds

  function monitorFrameRate() {
    let lastFrameTime = performance.now();

    function checkFrameRate(currentTime) {
      const deltaTime = currentTime - lastFrameTime;
      lastFrameTime = currentTime;

      // Calculate the current FPS
      const fps = 1000 / deltaTime;

      // Update frame times array
      frameTimes.push(fps);

      // Remove old entries older than the threshold duration
      while (frameTimes.length > 0 && (currentTime - (lastFrameTime - frameTimes.length * (1000 /
          60))) > thresholdDuration) {
        frameTimes.shift();
      }

      // Calculate average FPS over the threshold duration
      const averageFps = frameTimes.reduce((a, b) => a + b) / frameTimes.length;

      // Check if the average FPS is below the threshold
      if (averageFps < thresholdFps) {
        lowFpsDuration += deltaTime;
      } else {
        lowFpsDuration = 0;
      }

      // Trigger function if low FPS duration exceeds the threshold
      if (lowFpsDuration >= thresholdDuration) {
        console.log('Frame rate has been below 30 FPS!');
        removeSpline();
        lowFpsDuration = 0; // Reset to avoid multiple triggers
      }

      // Continue monitoring
      requestAnimationFrame(checkFrameRate);
    }

    requestAnimationFrame(checkFrameRate);
  }

  // Start monitoring the frame rate
  monitorFrameRate();
}

// Function to check if the Spline scene is loaded
function splineLoaded(isLoaded, splineCallback) {

  if (splineRemoved == true) {
    return;
  }

  // Set a flag to track whether the spline has been loaded within the timeout period
  let hasLoaded = false;

  // Start a 5-second timer that triggers the callback if the scene isn't loaded in time
  const timeout = setTimeout(() => {
    if (!hasLoaded) {
      // Remove spline if takes more than 5s
      console.log("Spline load timeout reached. Starting transition.");
      removeSplineDirect();

      if (typeof splineCallback === 'function') {
        splineCallback(); // Call the function after timeout if not already called
      }
    }
  }, 5000); // 5000 milliseconds = 5 seconds

  if (isLoaded) {
    hasLoaded = true; // Mark as loaded
    clearTimeout(timeout); // Clear the timeout if loaded within time
    if (typeof splineCallback === 'function') {
      splineCallback(); // Call the function you passed in
    }
  } else {
    // Spline Load event
    document.querySelector("#spline-bg").addEventListener("w-spline-load", (e) => {
      // console.log("Spline scene loaded in " + (e.timeStamp / 1000).toFixed(2) + " seconds.", e);
      console.log("Spline scene loaded in " + (e.timeStamp / 1000).toFixed(2) + " seconds.");
      hasLoaded = true; // Mark as loaded
      clearTimeout(timeout); // Clear the timeout if loaded
      splineLoaded(true, splineCallback); // Call splineLoaded with true when event is fired
    });
  }
}

// Don't touch
function delay(n) {
  n = n || 2000;
  return new Promise((done) => {
    setTimeout(() => {
      done();
    }, n);
  });
}

/**
 * Fire all scripts on page load
 */
function initScript() {
  initFlickitySlider();
  initSplitText();
  initCheckWindowHeight();
  initNavigationFunctions();
  initBasicFunctions();
  initScrollTriggerPlayVideoInview();
  initLenisCheckScrollUpDown();
  initScrollToAnchorLenis();
  setTimeout(initCheckTheme, transitionOffset);
  initScrolltriggerAnimations();
  initMixItUp();
  initSocialShare();
  initGlowSquare();
  initPixelGridHover();
}

/**
 * Reset Webflow
 */
function initResetWebflow(data) {
  // let parser = new DOMParser();
  // let dom = parser.parseFromString(data.next.html, "text/html");
  // let webflowPageId = $(dom).find("html").attr("data-wf-page");
  // $("html").attr("data-wf-page", webflowPageId);
  // window.Webflow && window.Webflow.destroy();
  // window.Webflow && window.Webflow.ready();
  // window.Webflow && window.Webflow.require("ix2").init();
}

/**
 * Barba Update Links outside Main on page Transition
 */
function initBarbaNavUpdate(data) {

  const updateItems = $(data.next.html).find('[data-barba-update]');

  $('header [data-barba-update]').each(function (index) {
    if ($(updateItems[index]).get(0)) {
      const newStatus = $(updateItems[index]).get(0).getAttribute('aria-current');
      $(this).attr('aria-current', newStatus);
    }
  });
}

/**
 * Window Inner Height Check
 */
function initCheckWindowHeight() {
  // https://css-tricks.com/the-trick-to-viewport-units-on-mobile/
  let vh = window.innerHeight * 0.01;
  document.documentElement.style.setProperty('--vh-in-px', `${vh}px`);
}

/**
 * Navigation Functions
 */
function initNavigationFunctions() {

  // Toggle Navigation
  $('[data-navigation-toggle="toggle"]').click(function () {
    if ($('[data-navigation-status]').attr('data-navigation-status') == 'not-active') {
      $('[data-navigation-status]').attr('data-navigation-status', 'active');
      scroll.stop();
    } else {
      $('[data-navigation-status]').attr('data-navigation-status', 'not-active');
      scroll.start();
    }
  });

  // Close Navigation
  $('[data-navigation-toggle="close"]').click(function () {
    $('[data-navigation-status]').attr('data-navigation-status', 'not-active');
    scroll.start();
  });

  // Key ESC - Close Navigation
  $(document).keydown(function (e) {
    if (e.keyCode == 27) {
      if ($('[data-navigation-status]').attr('data-navigation-status') == 'active') {
        $('[data-navigation-status]').attr('data-navigation-status', 'not-active');
        scroll.start();
      }
    }
  });

  // Toggle Navigation
  $('[data-toggle-bio]').click(function () {
    $(this).closest('.team-card').toggleClass('bio-active');
  });

}

/**
 * Basic Functions
 */
function initBasicFunctions() {

  // Portfolio Preview mode cards (WF limitation)
  if (document.querySelector('.portfolio-preview')) {
    $('.portfolio-preview').find('[data-logo-block="2"] .pp-card').remove();
    var selectedItems = $('.portfolio-preview').find('[data-logo-block="1"] .pp__logo-block-grid')
      .children().slice(4, 8);
    var clonedItems = selectedItems.clone();
    $('.portfolio-preview').find('[data-logo-block="2"] .pp__logo-block-grid').append(
      clonedItems);
    selectedItems.remove();
    $('.portfolio-preview').find('[data-logo-block="2"] .pp-card__border').addClass(
      'is--flipped');
  }
  if (document.querySelector('.pp__count-hidden')) {
    // Find hidden collection, count, updatetext, remove
    var countCollection = $('.pp__count-hidden').children().children().length;
    $('.pp__count-hidden').closest('section').find('[data-count]').text(countCollection);
    $('.pp__count-hidden').remove();
  }

  // Data Grid Hover
  $('[data-grid-hover-init]').each(function () {
    let grid = $(this);
    let gridItems = grid.find('[data-grid-hover-index]');

    // Add index to each grid item
    gridItems.each(function (index) {
      $(this).attr('data-grid-hover-index', index);
    });

    // Function to update the current active index
    function updateCurrentIndex(index) {
      grid.attr('data-grid-hover-current', index);
    }

    // Hover behavior
    gridItems.on('mouseenter mouseleave', function () {
      gridItems.attr('data-grid-hover-status', 'not-active');
      $(this).attr('data-grid-hover-status', 'active');
      updateCurrentIndex($(this).attr('data-grid-hover-index'));
    });

    grid.on('mouseleave', function () {
      gridItems.attr('data-grid-hover-status', 'not-active');
      updateCurrentIndex(null);
    });

    // Click behavior for touch devices
    gridItems.on('click', function () {
      gridItems.attr('data-grid-hover-status', 'not-active');
      $(this).attr('data-grid-hover-status', 'active');
      updateCurrentIndex($(this).attr('data-grid-hover-index'));
    });

    // Clicking outside the grid sets all items to "not-active"
    $(document).on('click', function (event) {
      // Check if the click occurred inside the grid
      if (!$(event.target).closest(grid).length) {
        gridItems.attr('data-grid-hover-status', 'not-active');
        updateCurrentIndex(null);
      }
    });
  });

  $('[data-grid-select-init]').each(function () {
    const $grid = $(this);
    const $gridItems = $grid.find('[data-grid-select-hover]');
    const $gridItemsMirror = $grid.find('[data-grid-select-mirror]');

    // Add index to each grid item and its mirror
    $gridItems.each(function (index) {
      $(this).attr('data-grid-select-index', index);
      $gridItemsMirror.eq(index).attr('data-grid-select-index', index);
    });

    // Make the first item active
    $grid.find('[data-grid-select-index="0"]').attr('data-grid-select-status', 'active');

    // Function to update the current active index
    function updateCurrentIndex(index) {
      $grid.attr('data-grid-select-current', index);
    }

    // Handle mouseenter event
    $gridItems.on('mouseenter', function () {
      const itemIndex = $(this).attr('data-grid-select-index');
      $grid.find('[data-grid-select-status]').attr('data-grid-select-status',
        'not-active');
      $grid.find(`[data-grid-select-index="${itemIndex}"]`).attr(
        'data-grid-select-status',
        'active');
      updateCurrentIndex(itemIndex);
    });
  });

  // Portfolio Sticky cards (WF limitation)
  const $portfolioStickyElements = $('.portfolio-sticky');

  if ($portfolioStickyElements.length) {
    $portfolioStickyElements.each(function () {
      const $portfolioSticky = $(this);

      $portfolioSticky.find('.ps-card').each(function () {
        const $card = $(this);
        const itemIndex = $card.attr('data-grid-select-index');
        const $clonedTags = $card.find('.tags').clone();
        const $stickySingleTags = $portfolioSticky.find(
          `.ps__sticky-single[data-grid-select-index="${itemIndex}"] .ps__sticky-single-tags`
        );

        if ($stickySingleTags.length) {
          $stickySingleTags.append($clonedTags);
        }
      });

      // Find hidden collection, count, update text
      const countCollection = $portfolioSticky.find('.ps__col-group > * > *').length;
      $portfolioSticky.parent().find('[data-count]').text(countCollection);
    });
  }

  // When page is portfolio child, add data attr
  if (document.querySelector('.p-header')) {
    $('header .link[href="/portfolio"]').attr('aria-current', 'page');
  }

  // Data Webflow Siblings © Code by Dennis
  $('[data-wf-siblings-init]').each(function () {
    const $wfs = $(this);
    const $wfsCollection = $wfs.find('[data-wf-siblings-collection]');
    const wfsCurrent = $wfs.attr('data-wf-siblings-current');

    // Assign index to each collection item based on its slug
    $wfsCollection.find('[data-wf-siblings-collection-slug]').each(function (index) {
      $(this).attr('data-wf-siblings-collection-index', index);
    });

    // Get the current item's index
    const $currentItem = $wfsCollection.find(
      `[data-wf-siblings-collection-slug="${wfsCurrent}"]`);
    const wfsCurrentIndex = parseInt($currentItem.attr('data-wf-siblings-collection-index'),
      10);

    // Get the total number of items in the collection
    const wfsCountTotal = $wfsCollection.find('[data-wf-siblings-collection-slug]').length;

    // Determine the previous and next item indices, ensuring wrap-around
    const wfsPrevIndex = (wfsCurrentIndex - 1 + wfsCountTotal) % wfsCountTotal;
    const wfsNextIndex = (wfsCurrentIndex + 1) % wfsCountTotal;

    // Get the previous and next items
    const $wfsItemPrev = $wfsCollection.find(
      `[data-wf-siblings-collection-index="${wfsPrevIndex}"]`);
    const $wfsItemNext = $wfsCollection.find(
      `[data-wf-siblings-collection-index="${wfsNextIndex}"]`);

    // Update the UI with the gathered information
    $wfs.find('[data-wf-siblings-count-current]').text(String(wfsCurrentIndex + 1).padStart(2,
      '0'));
    $wfs.find('[data-wf-siblings-count-total]').text(String(wfsCountTotal).padStart(2, '0'));
    $wfs.find('[data-wf-siblings-next]').attr('href', $wfsItemNext.find(
      '[data-wf-siblings-collection-url]').attr('href'));
    $wfs.find('[data-wf-siblings-prev]').attr('href', $wfsItemPrev.find(
      '[data-wf-siblings-collection-url]').attr('href'));

    // Remove Hidden collection from page
    $wfsCollection.remove();
  });

  // When page is portfolio child, add data attr
  if (document.querySelector('.article')) {
    $('header .link[href="/news-insights"]').attr('aria-current', 'page');
  }

  // Add looping title
  $('[data-looping-title]').each(function () {
    const loopingTitle = $(this);
    const loopingTitleArray = loopingTitle.attr('data-looping-title').split(', ');

    // Prepare the container by removing styles and adding a container for the words
    loopingTitle.removeClass('text-gradient').css('color', 'transparent').css('user-select',
      'none');
    loopingTitle.find('.single-word-inner').append('<div class="looping-title"></div>');

    // Loop through the array and create a div for each word
    $.each(loopingTitleArray, function (index, word) {
      // Create a new div element with the word as text
      var singleTitle = $('<div class="looping-title-single single-word text-gradient">')
        .text(word);

      // Append the new div to the container
      loopingTitle.find('.looping-title').append(singleTitle);
    });

    loopingTitle.find('.looping-title-single.text-gradient').last().addClass('is--gold');

    // Get all div elements inside the container after creating them
    var wordsDivs = loopingTitle.find('.looping-title-single');
    var currentIndex = 0; // Start from the first word

    gsap.set(wordsDivs, {
      yPercent: 100,
    });

    gsap.set(wordsDivs.first(), {
      yPercent: 0,
    });

    function loopWords() {
      // Current and next divs
      var currentDiv = $(wordsDivs[currentIndex]);
      var nextIndex = (currentIndex + 1) % wordsDivs.length; // Loop back to the first word
      var nextDiv = $(wordsDivs[nextIndex]);

      // Animate the current div out of view

      gsap.to(currentDiv, {
        duration: durationPageTransition,
        yPercent: -100,
        ease: "primary-ease",
        opacity: 0
      });

      // Animate the next div into view
      gsap.fromTo(nextDiv, { yPercent: 100, opacity: 0 }, // Start from below
        { yPercent: 0, opacity: 1, duration: durationPageTransition, ease: "primary-ease" }
      );

      // Update the current index for the next iteration
      currentIndex = nextIndex;
    }

    // Start the loop after a 4-second delay (4000 milliseconds)
    setTimeout(function () {
      // Start the animation loop
      setInterval(loopWords, 2000);

      // Trigger the loop immediately to start the animation after the delay
      loopWords();
    }, 3000);
  });

  // Data Grid Hover
  $('[data-link-external], .featured-card__quote .link, .p-header__website .link, .team-card__socials .link')
    .each(
      function () {
        $(this).attr('target', '_blank');
      });

  // Change founder to founders if multiple
  $('.p-header__founder > p').each(function () {
    if ($(this).text().includes(',')) {
      $(this).parent().find('.tag p').text('Founders');
    }
  });
}

/**
 * Play Video Inview
 */
function initScrollTriggerPlayVideoInview() {

  let allVideoDivs = gsap.utils.toArray('.playpauze');

  allVideoDivs.forEach((videoDiv, i) => {

    let videoElem = videoDiv.querySelector('video')

    ScrollTrigger.create({
      trigger: videoElem,
      start: '0% 120%',
      end: '100% -20%',
      onEnter: () => videoElem.play(),
      onEnterBack: () => videoElem.play(),
      onLeave: () => videoElem.pause(),
      onLeaveBack: () => videoElem.pause(),
    });
  });
}

/**
 * Lenis - Check Scroll up or Down
 */

function initLenisCheckScrollUpDown() {
  var lastScrollTop = 0;
  var threshold = 50;
  var thresholdTop = 50;

  // Reference to the scroll event handler so it can be removed later
  var scrollHandler = function (e) {
    var nowScrollTop = e.targetScroll;

    if (Math.abs(lastScrollTop - nowScrollTop) >= threshold) {

      // Check Scroll Direction
      if (nowScrollTop > lastScrollTop) {
        $("[data-scrolling-direction]").attr('data-scrolling-direction', 'down');
      } else {
        $("[data-scrolling-direction]").attr('data-scrolling-direction', 'up');
      }
      lastScrollTop = nowScrollTop;

      // Check if Scroll Started
      if (nowScrollTop > thresholdTop) {
        $("[data-scrolling-started]").attr('data-scrolling-started', 'true');
      } else {
        $("[data-scrolling-started]").attr('data-scrolling-started', 'false');
      }
    }
  };

  function startCheckScroll() {
    scroll.on('scroll', scrollHandler);
  }

  function stopCheckScroll() {
    scroll.off('scroll', scrollHandler);
  }

  startCheckScroll();

  // Reset instance after page transition
  barba.hooks.afterLeave(() => {
    stopCheckScroll(); // Clean up before leaving the page
  });

  barba.hooks.after(() => {
    lastScrollTop = 0; // Reset the lastScrollTop value
    startCheckScroll(); // Reinitialize scroll checking on the new page
  });
}

/**
 * Lenis - ScrollTo Anchor Links
 */
function initScrollToAnchorLenis() {

  $("[data-anchor-target]").click(function () {

    let targetScrollToAnchorLenis = $(this).attr('data-anchor-target');
    scroll.scrollTo(targetScrollToAnchorLenis, {
      duration: 1.2,
      easing: (x) => (x < 0.5 ? 8 * x * x * x * x : 1 - Math.pow(-2 * x + 2, 4) / 2),
      force: true,
      offset: 0
    });

  });
}

/**
 * Check Theme of Sections
 */
function initCheckTheme() {

  function checkThemeSection() {
    var themeSections = document.querySelectorAll("section[data-theme-section]");
    var themeObserverOffset = mainNavBarHeight / 2;

    themeSections.forEach(function (themeSection) {
      var rect = themeSection.getBoundingClientRect();
      var themeSectionTop = rect.top;
      var themeSectionBottom = rect.bottom;

      if (themeSectionTop <= themeObserverOffset && themeSectionBottom >=
        themeObserverOffset) {

        // Check [data-theme-section]
        var themeSectionActive = themeSection.getAttribute('data-theme-section');
        var $themeNav = $('[data-theme-nav]');
        if ($themeNav.attr('data-theme-nav') !== themeSectionActive) {
          $themeNav.attr('data-theme-nav', themeSectionActive);
        }

        // Check [data-bg-section]
        var bgSectionActive = themeSection.getAttribute('data-bg-section');
        var $bgNav = $('[data-bg-nav]');
        if ($bgNav.attr('data-bg-nav') !== bgSectionActive) {
          $bgNav.attr('data-bg-nav', bgSectionActive);
        }
      }
    });

    var indexItems = document.querySelectorAll("[data-item-index-target]");
    var indexItemsObserverOffset = window.innerHeight / 2;

    indexItems.forEach(function (indexItem) {
      var rect = indexItem.getBoundingClientRect();
      var indexItemTop = rect.top;
      var indexItemBottom = rect.bottom;

      if (indexItemTop <= indexItemsObserverOffset && indexItemBottom >=
        indexItemsObserverOffset) {

        // Check [data-item-index]
        var indexItemActive = indexItem.getAttribute('data-item-index');
        var $indexItemCurrent = $('[data-item-index-current]');
        if ($indexItemCurrent.attr('data-item-index-current') !== indexItemActive) {
          $indexItemCurrent.attr('data-item-index-current', indexItemActive);
          $('[data-item-index="' + indexItemActive + '"]').attr('data-item-index-status',
              'active')
            .siblings().attr('data-item-index-status', 'not-active');
        }

      }
    });
  }

  function startThemeCheck() {
    document.addEventListener("scroll", checkThemeSection);
  }

  function stopThemeCheck() {
    document.removeEventListener("scroll", checkThemeSection);
  }

  // Page load init
  checkThemeSection();
  startThemeCheck();

  // Cleanup and reinit on page transition
  barba.hooks.afterLeave(() => {
    stopThemeCheck(); // Clean up before leaving the page
  });

  barba.hooks.after(() => {
    checkThemeSection(); // Recheck immediately after transition
    startThemeCheck(); // Reinitialize scroll checking
  });
}

/**
 * GSAP Split Text
 */
function initSplitText() {

  var splitTextLines = new SplitText("[data-split-lines='not-split']", {
    type: "lines",
    linesClass: "single-line"
  });
  $('[data-split-lines="not-split"] .single-line').wrapInner('<div class="single-line-inner">');
  $(splitTextLines.elements).each(function () {
    if ($(this).attr('data-split-lines') == 'not-split') {
      $(this).attr('data-split-lines', 'is-split');
    }
  });

  var splitWords = new SplitText("[data-split-words]", {
    type: "words",
    wordsClass: "single-word"
  });
  $('[data-split-words] .single-word').wrapInner('<div class="single-word-inner">');

}

/**
 * Flickity Slider
 */
function initFlickitySlider() {

  // Source
  // https://flickity.metafizzy.co/
  // https://codepen.io/GuiderWG/pen/xxEbKRR

  document.querySelectorAll('[data-flickity-marquee-init]').forEach((sliderThis, index) => {
    const sliderIndexID = `flickity-marquee-id-${index}`;
    sliderThis.id = sliderIndexID;

    const flickitySliderGroup = sliderThis.querySelector('.marquee-slider');
    const flickitySliderSlide = sliderThis.querySelector('.marquee-slider_slide > *');

    /* Remove styling */
    flickitySliderGroup.style.display = 'block';

    let oldProgress = 0;
    let direction = -1; // Initial direction is set to -1
    let isPlaying = false;
    let requestId;
    let userDragged = false; // Flag to track if the user has dragged
    let isWaitingForSettle = false;

    // Check if the device is touch-capable
    const isTouchDevice = () => 'ontouchstart' in window || navigator.maxTouchPoints > 0 ||
      navigator.msMaxTouchPoints > 0;

    /* Flickity Slider */
    const flickitySlider = new Flickity(flickitySliderGroup, {
      resize: true,
      wrapAround: true,
      prevNextButtons: false,
      pageDots: false,
      cellAlign: "left",
      percentPosition: true,
      freeScroll: true,
      setGallerySize: true,
      on: {
        scroll: (progress) => {
          if (Math.abs(progress - oldProgress) > 0.01) {
            direction = progress < oldProgress ? 1 : -1;
            oldProgress = progress;
          }
        },
        staticClick: (event, pointer, cellElement, cellIndex) => {
          if (cellElement && isTouchDevice()) {
            flickitySlider.select(cellIndex);
            sliderThis.setAttribute('data-flickity-interacted',
              'true'); // Set to true when interacting
          }
        }
      }
    });

    flickitySlider.x = 0;

    const play = () => {
      if (!isPlaying || userDragged) return; // Check the flag
      flickitySlider.x += direction;
      flickitySlider.settle(flickitySlider.x);
      requestId = window.requestAnimationFrame(play);
    };

    const pause = () => {
      if (requestId) {
        window.cancelAnimationFrame(requestId);
        requestId = undefined;
      }
      isPlaying = false;
    };

    const startAnimation = () => {
      if (!isPlaying && !userDragged) {
        isPlaying = true;
        play();
      }
    };

    const isElementInViewport = () => {
      const rect = flickitySliderGroup.getBoundingClientRect();
      return (
        rect.top >= 0 &&
        rect.left >= 0 &&
        rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&
        rect.right <= (window.innerWidth || document.documentElement.clientWidth)
      );
    };

    sliderThis.addEventListener('mouseenter', pause);
    sliderThis.addEventListener('mouseleave', () => {
      if (!isWaitingForSettle && isElementInViewport()) {
        startAnimation();
      }
    });

    flickitySlider.on('settle', () => {
      if (isWaitingForSettle && isElementInViewport()) {
        startAnimation();
        isWaitingForSettle = false;
      }
    });

    flickitySlider.on('dragStart', () => {
      pause();
      isWaitingForSettle = true;
      if (isTouchDevice()) {
        userDragged = true;
        sliderThis.setAttribute('data-flickity-interacted', 'true');
      }
    });

    flickitySlider.on('dragEnd', () => {
      isWaitingForSettle = true;
    });

    // Intersection Observer to pause/play based on visibility
    const observer = new IntersectionObserver(entries => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          startAnimation();
        } else {
          pause();
        }
      });
    }, { threshold: 0.1 });

    observer.observe(flickitySliderGroup);

    barba.hooks.afterLeave(() => {
      flickitySlider.destroy();
      sliderThis.removeEventListener('mouseenter', pause);
      sliderThis.removeEventListener('mouseleave', startAnimation);
      observer.disconnect();
      sliderThis.removeAttribute('data-flickity-interacted');
    });

    // Event listener to detect clicks outside the slider
    document.addEventListener('click', (event) => {
      if (isTouchDevice()) {
        // Check if the click was outside the slider element
        if (!sliderThis.contains(event.target)) {
          sliderThis.removeAttribute('data-flickity-interacted'); // Remove the attribute
        }
      }
    });
  });

  // Slider Cards
  $('[data-flickity-cards-init]').each(function (index) {

    var sliderIndexID = 'flickity-slider-type-cards-id-' + index;
    $(this).attr('id', sliderIndexID);

    var sliderThis = $(this);

    var sliderAlign = 'left';
    var sliderLoop = false;
    if (sliderThis.attr('data-flickity-cards-init') == "center") {
      sliderAlign = 'center';
      sliderLoop = true;
    }

    /* Remove styling */
    sliderThis.find('.card-slider').css('display', 'block');

    var flickitySlider = sliderThis.find('.card-slider').flickity({
      // options
      contain: true,
      wrapAround: sliderLoop,
      dragThreshold: 10,
      prevNextButtons: false,
      pageDots: false,
      cellAlign: sliderAlign,
      // selectedAttraction: 0.015,
      // friction: 0.25,
      percentPosition: true,
      freeScroll: false,
      on: {
        'change': (cellIndex) => {
          sliderThis.closest('section').find('[data-flickity-control-index="' +
            cellIndex + '"]').attr(
            'data-flickity-control-status', 'active').siblings().attr(
            'data-flickity-control-status', 'not-active');
        }
      }
    });

    // Flickity instance
    var flkty = flickitySlider.data('flickity');

    // Index 
    sliderThis.closest('section').find('[data-flickity-control-index]').on('click',
      function () {
        flickitySlider.flickity('select', $(this).attr('data-flickity-control-index'));
      });

    // previous
    sliderThis.closest('section').find('[data-flickity-control="prev"]').on(
      'click',
      function () {
        flickitySlider.flickity('previous');
      });

    // next
    sliderThis.closest('section').find('[data-flickity-control="next"]').on(
      'click',
      function () {
        flickitySlider.flickity('next');
      });

  });
}

/**
 * Scrolltrigger Animations Desktop + Mobile
 */
function initScrolltriggerAnimations() {

  if (document.querySelector('main [data-split-lines][data-animation-scroll]')) {
    $('main [data-split-lines][data-animation-scroll]').each(function () {
      let triggerElement = $(this);
      let targetElement = $(this).find('.single-line-inner');

      let tl = gsap.timeline({
        scrollTrigger: {
          trigger: triggerElement,
          start: "0% 90%",
          end: "100% 0%",
          toggleActions: "play none none none"
        }
      });

      tl.fromTo(targetElement, {
        yPercent: 120,
        rotate: 0.001
      }, {
        yPercent: 0,
        rotate: 0.001,
        ease: "primary-ease",
        duration: durationDefault,
        stagger: staggerDefault
      });
    });
  }

  if (document.querySelector('main [data-split-words][data-animation-scroll]')) {
    $('main [data-split-words][data-animation-scroll]').each(function () {
      let triggerElement = $(this);
      let targetElement = $(this).find('.single-word-inner');

      let tl = gsap.timeline({
        scrollTrigger: {
          trigger: triggerElement,
          start: "0% 90%",
          end: "100% 0%",
          toggleActions: "play none none none"
        }
      });

      tl.fromTo(targetElement, {
        yPercent: 120,
        rotate: 0.001
      }, {
        yPercent: 0,
        rotate: 0.001,
        ease: "primary-ease",
        duration: durationDefault,
        stagger: staggerDefault,
        clearProps: "all"
      });
    });
  }

  if (document.querySelector('[data-animation-scroll="fade"]')) {
    $('[data-animation-scroll="fade"]').each(function () {
      let triggerElement = $(this);
      let targetElement = $(this);

      let tl = gsap.timeline({
        scrollTrigger: {
          trigger: triggerElement,
          start: "0% 90%",
          end: "100% 0%",
          toggleActions: "play none none none"
        }
      });

      tl.fromTo(targetElement, {
        y: "3em",
        rotate: 0.001,
        autoAlpha: 0
      }, {
        y: 0,
        rotate: 0.001,
        autoAlpha: 1,
        ease: "primary-ease",
        duration: durationDefault,
        stagger: (staggerDefault * 2),
        clearProps: "all"
      }, 0.2);
    });
  }

  if (document.querySelector('[data-animation-scroll="group"]')) {
    $('[data-animation-scroll="group"]').each(function () {
      let triggerElement = $(this);
      let targetElementFadeBefore = triggerElement.find(
        '[data-animation-scroll="target-before"]');
      let targetElementWords = triggerElement.find('.single-word-inner');
      let targetElementFade = triggerElement.find('[data-animation-scroll="target"]');

      let tl = gsap.timeline({
        scrollTrigger: {
          trigger: triggerElement,
          start: "0% 90%",
          end: "100% 0%",
          toggleActions: "play none none none"
        }
      });

      if (targetElementFadeBefore.length) {
        tl.fromTo(targetElementFadeBefore, {
          y: "2em",
          rotate: 0.001,
          autoAlpha: 0
        }, {
          y: 0,
          rotate: 0.001,
          autoAlpha: 1,
          ease: "primary-ease",
          duration: durationDefault,
          stagger: staggerDefault,
          clearProps: "all"
        });
      }

      let wordsOffset;
      if (targetElementFadeBefore.length) {
        wordsOffset = "> -1";
      } else {
        wordsOffset = "-0.2";
      }

      if (targetElementWords.length) {
        tl.fromTo(targetElementWords, {
          yPercent: 110,
          rotate: 0.001
        }, {
          yPercent: 0,
          rotate: 0.001,
          ease: "primary-ease",
          duration: durationDefault,
          stagger: staggerDefault,
          clearProps: "all"
        }, wordsOffset);
      }

      let fadeOffset;
      if (targetElementFadeBefore.length) {
        fadeOffset = "> -1";
      } else if (targetElementWords.length) {
        fadeOffset = "> -1";
      } else {
        fadeOffset = "-0";
      }

      if (targetElementFade.length) {
        tl.fromTo(targetElementFade, {
          y: "2em",
          rotate: 0.001,
          autoAlpha: 0
        }, {
          y: 0,
          rotate: 0.001,
          autoAlpha: 1,
          ease: "primary-ease",
          duration: durationDefault,
          stagger: (staggerDefault * 2),
          clearProps: "all"
        }, fadeOffset);
      }

    });
  }

  if (document.querySelector('.about-header__graph-group')) {
    $('.about-header__graph-group').each(function () {
      let triggerElement = $(this);
      let targetElement = $(this).find('.about-header__graph-img');

      let tl = gsap.timeline({
        scrollTrigger: {
          trigger: triggerElement,
          start: "0% 50%",
          end: "100% 50%",
          toggleActions: "play none none none"
        }
      });

      gsap.set(triggerElement.find(
        '.about-header__graph-img:nth-child(3), .about-header__graph-img:nth-child(4)'), {
        clipPath: "polygon(0% 0%, 0% 0%, 0% 100%, 0% 100%)",
      });

      tl.fromTo(triggerElement.find('.about-header__graph-img:nth-child(4)'), {
        clipPath: "polygon(0% 0%, 0% 0%, 0% 100%, 0% 100%)",
      }, {
        clipPath: "polygon(0% 0%, 94.3% 0%, 94.3% 100%, 0% 100%)",
        ease: "Expo.easeInOut",
        duration: 2.5
      });

      tl.fromTo(triggerElement.find('.about-header__graph-img:nth-child(3)'), {
        clipPath: "polygon(0% 0%, 0% 0%, 0% 100%, 0% 100%)",
      }, {
        clipPath: "polygon(0% 0%, 94.3% 0%, 94.3% 100%, 0% 100%)",
        ease: "Expo.easeInOut",
        duration: 2.5
      }, "< 1");
    });
  }

  ScrollTrigger.matchMedia({
    "(min-width: 992px)": function () {
      if (document.querySelector('.home-intro__card')) {
        $('.home-intro').each(function () {
          let triggerElement = $(this);
          let targetElement = $(this).find('.home-intro__card');

          let tl = gsap.timeline({
            scrollTrigger: {
              trigger: triggerElement,
              start: "0% 100%",
              end: "100% 0%",
              scrub: 0
            }
          });

          tl.fromTo(triggerElement.find('.home-intro__card:nth-child(1)'), {
            yPercent: 0,
            rotate: 0.001,
          }, {
            yPercent: 30,
            rotate: 0.001,
            ease: "none",
            duration: durationDefault
          }, 0);

          tl.fromTo(triggerElement.find('.home-intro__card:nth-child(2)'), {
            yPercent: 20,
            rotate: 0.001,
          }, {
            yPercent: 10,
            rotate: 0.001,
            ease: "none",
            duration: durationDefault
          }, 0);

          tl.fromTo(triggerElement.find('.home-intro__card:nth-child(3)'), {
            yPercent: 40,
            rotate: 0.001,
          }, {
            yPercent: -10,
            rotate: 0.001,
            ease: "none",
            duration: durationDefault
          }, 0);

          tl.fromTo(triggerElement.find('.home-intro__card:nth-child(4)'), {
            yPercent: 60,
            rotate: 0.001,
          }, {
            yPercent: -30,
            rotate: 0.001,
            ease: "none",
            duration: durationDefault
          }, 0);
        });
      }

      if (document.querySelector('.offerings-about__grid')) {
        $('.offerings-about__grid').each(function () {
          let triggerElement = $(this);
          let targetElement = $(this).find('.offerings-about__single');

          let tl = gsap.timeline({
            scrollTrigger: {
              trigger: triggerElement,
              start: "0% 100%",
              end: "100% 0%",
              scrub: 0
            }
          });

          tl.fromTo(triggerElement.find('.offerings-about__single:nth-child(1)'), {
            yPercent: 30,
            rotate: 0.001,
          }, {
            yPercent: -20,
            rotate: 0.001,
            ease: "none",
            duration: durationDefault
          }, 0);

          tl.fromTo(triggerElement.find('.offerings-about__single:nth-child(2)'), {
            yPercent: -30,
            rotate: 0.001,
          }, {
            yPercent: 20,
            rotate: 0.001,
            ease: "none",
            duration: durationDefault
          }, 0);
        });
      }
    }
  });

  if (document.querySelector('.sticky-btn')) {
    $('.footer').each(function () {
      let triggerElement = $(this);
      let targetElement = $('.sticky-btn');

      let tl = gsap.timeline({
        scrollTrigger: {
          trigger: triggerElement,
          start: "0% 100%",
          end: "100% 100%",
          toggleActions: "play none none reverse"
        }
      });

      tl.fromTo(targetElement, {
        yPercent: -100,
        rotate: 0.001,
      }, {
        yPercent: 0,
        rotate: 0.001,
        ease: "primary-ease",
        duration: durationDefault
      });
    });
  }

}

/**
 * MixItUp
 */
function initMixItUp() {

  // Source: https://www.kunkalabs.com/mixitup/

  // Set the reference to the container
  const mixContainer = document.querySelector("[data-mix-container]");

  if (!mixContainer) {
    return;
  }

  var mixer = mixitup(mixContainer, {
    animation: {
      effectsOut: 'fade scale(0.9) stagger(100ms)',
      effectsIn: 'fade scale(0.9) stagger(100ms)',
      easing: 'cubic-bezier(0.62, 0.05, 0.01, 0.99)',
      duration: 500,
      staggerSequence: function (i) {
        return i % 3;
      }
    },
    callbacks: {
      onMixEnd: function (state) {
        ScrollTrigger.refresh();
        if (state.hasFailed) {
          $('[data-mix-empty]').attr('data-mix-empty', 'true');
        }
        else {
          $('[data-mix-empty]').attr('data-mix-empty', 'false');
        }
      }
    },
  });

}

/**
 * Social Share
 */
function initSocialShare() {

  // Set the reference to the container
  const socialShare = document.querySelector(".article__share");

  if (!socialShare) {
    return;
  }

  const socialURL = window.location.href;
  const socialTitle = $('[data-share-title]').attr('data-share-title');

  $('[data-share-via="X"]').attr('href', 'https://twitter.com/intent/tweet?url=' + socialURL +
    '&text=' + socialTitle);
  $('[data-share-via="Mail"]').attr('href', 'mailto:?subject=' + socialTitle + '&body=' +
    socialURL);
  $('[data-share-via="LinkedIn"]').attr('href',
    'https://www.linkedin.com/shareArticle?mini=true&url=' + socialURL + '&title=' + socialTitle);
  $('[data-share-via="Reddit"]').attr('href', 'https://www.reddit.com/submit?url=' + socialURL +
    '&title=' + socialTitle);
  $('[data-share-via="Telegram"]').attr('href', 'https://t.me/share/url?url=' + socialURL +
    '&title=' +
    socialTitle);
  $('[data-share-via="WhatsApp"]').attr('href', 'https://wa.me/?text=' + socialTitle + '%20' +
    socialURL);

  $('[data-share-via="Link"]').click(function () {
    navigator.clipboard.writeText(socialURL).then(() => {
      $(this).find('.btn-social__confirm').css('opacity', '1');
      setTimeout(() => {
        $(this).find('.btn-social__confirm').css('opacity', '0');
      }, 2000);
    });
  });

}

/**
 * Glow Square
 */
function initGlowSquare() {
  // Select all glow containers
  const glowContainers = document.querySelectorAll('.glow-container');

  // Iterate over each container and initialize glow effect
  glowContainers.forEach((container) => {
    const glowBox = container;
    const glowTop = container.querySelector('.glow.is--top');
    const glowRight = container.querySelector('.glow.is--right');
    const glowBottom = container.querySelector('.glow.is--bottom');
    const glowLeft = container.querySelector('.glow.is--left');

    if (!glowBox || !glowTop || !glowRight || !glowBottom || !glowLeft)
      return; // Ensure all elements exist

    const handleMouseMove = (event) => {
      // Get the bounding rectangle of the square
      const rect = glowBox.getBoundingClientRect();

      // Calculate the relative X and Y positions inside the square
      const relativeX = event.clientX - rect.left;
      const relativeY = event.clientY - rect.top;

      // Determine the distances to each side
      const distanceTop = relativeY;
      const distanceBottom = rect.height - relativeY;
      const distanceLeft = relativeX;
      const distanceRight = rect.width - relativeX;

      // Calculate opacity based on distance (closer = higher opacity)
      const maxOpacity = 0.9; // Maximum opacity when very close
      const minOpacity = 0; // Minimum opacity when far away
      const blendFactor = 0.5; // Determines how much to blend opacities near corners

      // Calculate distances as ratios from 0 (closest) to 1 (farthest)
      const ratioTop = distanceTop / (rect.height / 2);
      const ratioBottom = distanceBottom / (rect.height / 2);
      const ratioLeft = distanceLeft / (rect.width / 2);
      const ratioRight = distanceRight / (rect.width / 2);

      // Calculate blended opacities for corners
      const opacityTop = Math.max(
        minOpacity,
        maxOpacity * (1 - ratioTop) * (ratioLeft < 1 && ratioRight < 1 ? blendFactor : 1)
      );
      const opacityBottom = Math.max(
        minOpacity,
        maxOpacity * (1 - ratioBottom) * (ratioLeft < 1 && ratioRight < 1 ? blendFactor : 1)
      );
      const opacityLeft = Math.max(
        minOpacity,
        maxOpacity * (1 - ratioLeft) * (ratioTop < 1 && ratioBottom < 1 ? blendFactor : 1)
      );
      const opacityRight = Math.max(
        minOpacity,
        maxOpacity * (1 - ratioRight) * (ratioTop < 1 && ratioBottom < 1 ? blendFactor : 1)
      );

      // Set the opacities for each side
      glowTop.style.opacity = opacityTop;
      glowBottom.style.opacity = opacityBottom;
      glowLeft.style.opacity = opacityLeft;
      glowRight.style.opacity = opacityRight;
    };

    const handleMouseLeave = () => {
      // Reset all glows, with bottom glow remaining more active
      glowTop.style.opacity = 0;
      glowBottom.style.opacity = 0.9; // Higher default opacity for the bottom glow
      glowLeft.style.opacity = 0;
      glowRight.style.opacity = 0;
    };

    // Attach event listeners
    glowBox.addEventListener('mousemove', handleMouseMove);
    glowBox.addEventListener('mouseleave', handleMouseLeave);

    // Store cleanup function to remove event listeners
    container.cleanup = () => {
      glowBox.removeEventListener('mousemove', handleMouseMove);
      glowBox.removeEventListener('mouseleave', handleMouseLeave);
    };
  });
}

barba.hooks.afterLeave(() => {
  // Clean up listeners for all glow containers after leaving
  document.querySelectorAll('.glow-container').forEach((container) => {
    if (container.cleanup) {
      container.cleanup();
    }
  });
});

/**
 * Pixel Grid Hover
 */
function initPixelGridHover() {
  // Define the duration for each animation step
  const animationStepDuration = 0.3; // Adjust this value to control the timing
  const gridSize = 10; // Number of pixels per row and column (adjustable)

  // Calculate pixel size dynamically
  const pixelSize = 100 / gridSize; // Calculate the size of each pixel as a percentage

  // Select all cards
  const cards = document.querySelectorAll('.team-card');

  // Loop through each card
  cards.forEach((card) => {
    const pixelGrid = card.querySelector('.pixel-grid');

    // Create a grid of pixels dynamically based on the gridSize
    for (let row = 0; row < gridSize; row++) {
      for (let col = 0; col < gridSize; col++) {
        const pixel = document.createElement('div');
        pixel.classList.add('pixel');
        pixel.style.width = `${pixelSize}%`; // Set the pixel width dynamically
        pixel.style.height = `${pixelSize}%`; // Set the pixel height dynamically
        pixel.style.left = `${col * pixelSize}%`; // Set the pixel's horizontal position
        pixel.style.top = `${row * pixelSize}%`; // Set the pixel's vertical position
        pixelGrid.appendChild(pixel);
      }
    }

    const pixels = pixelGrid.querySelectorAll('.pixel');
    const totalPixels = pixels.length;
    const staggerDuration = animationStepDuration /
      totalPixels; // Calculate stagger duration dynamically

    // Mouse enter animation
    const onMouseEnter = () => {
      gsap.killTweensOf(pixels); // Reset any ongoing animations
      gsap.set(pixels, { display: 'none' }); // Make all pixels invisible instantly

      // 0 - animationStepDuration: Show pixels randomly
      gsap.to(pixels, {
        display: 'block',
        duration: 0,
        stagger: {
          each: staggerDuration,
          from: 'random'
        }
      });

      // animationStepDuration: Add class to parent card
      gsap.delayedCall(animationStepDuration, () => card.classList.add('active'));

      // animationStepDuration - (2 * animationStepDuration): Hide pixels randomly
      gsap.to(pixels, {
        display: 'none',
        duration: 0,
        delay: animationStepDuration,
        stagger: {
          each: staggerDuration,
          from: 'random'
        }
      });
    };

    // Mouse leave animation
    const onMouseLeave = () => {
      gsap.killTweensOf(pixels); // Reset any ongoing animations
      gsap.set(pixels, { display: 'none' }); // Make all pixels invisible instantly

      // 0 - animationStepDuration: Show pixels randomly
      gsap.to(pixels, {
        display: 'block',
        duration: 0,
        stagger: {
          each: staggerDuration,
          from: 'random'
        }
      });

      // animationStepDuration: Remove class from parent card
      gsap.delayedCall(animationStepDuration, () => card.classList.remove('active'));

      // animationStepDuration - (2 * animationStepDuration): Hide pixels randomly
      gsap.to(pixels, {
        display: 'none',
        duration: 0,
        delay: animationStepDuration,
        stagger: {
          each: staggerDuration,
          from: 'random'
        }
      });
    };

    // Attach mouse events
    card.addEventListener('mouseenter', onMouseEnter);
    card.addEventListener('mouseleave', onMouseLeave);
  });

}


